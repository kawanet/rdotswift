// rdotswift.js

exports.format = format;

var Identifier = require("./src/ATS/Identifier");
var TokenKinds = require("./src/Syntax/TokenKinds");

var CLASS = "class";
var IF = "if";
var TYPES = ["array", "bool", "color", "dimen", "integer", "string"];
var MAX_COMMENT_LENGTH = 64;

/**
 * generates Swift source code
 *
 * @param R {Object}
 * @param [options] {Object}
 * @returns {String}
 */

function format(R, options) {
  if (!options) options = {};
  var out = [];
  var header = (options.header !== false);

  if (header) {
    out.push("// Generated by rdotswift <https://github.com/kawanet/rdotswift>");
    out.push("");
  }

  if (options[IF]) {
    out.push("#if " + options[IF]);
    out.push("");
  }

  if (header) {
    if (options.appkit) {
      out.push("import AppKit");
    } else {
      out.push("import UIKit");
    }
    out.push("");
  }

  if (!options.extension) {
    var className = options[CLASS] || "R";
    out.push("final class " + className + " {");
    TYPES.map(function(type, idx) {
      if (idx) out.push("");
      out.push("    final class " + type + " {");
      out.push("    }");
    });
    out.push("}");
    out.push("");
  }

  if (options.source) {
    out.push("// " + options.source);
    out.push("");
  }

  out = out.concat(makeExtension("array", R.array, arrayFilter, options));
  out = out.concat(makeExtension("bool", R.bool, boolFilter, options));
  out = out.concat(makeExtension("color", R.color, colorFilter, options));
  out = out.concat(makeExtension("dimen", R.dimen, dimenFilter, options));
  out = out.concat(makeExtension("integer", R.integer, integerFilter, options));
  out = out.concat(makeExtension("string", R.string, stringFilter, options));

  if (options.endif || (options[IF] && options.endif !== false)) {
    out.push("#endif");
    out.push("");
  }

  return out.join("\n");

  function integerFilter(key, val) {
    return prefix(key) + " = " + val;
  }

  function arrayFilter(key, val) {
    val = JSON.stringify(val);
    val = prefix(key) + " = " + val;
    return val;
  }

  function stringFilter(key, val) {
    val = JSON.stringify(val + "");
    return prefix(key) + " = " + val;
  }

  function colorFilter(key, val) {
    if (!val) return;

    var row = prefix(key) + " = ";
    val += "";

    // #RGB -> #RRGGBB
    // #ARGB -> #AARRGGBB
    if (val.search(/^#[0-9A-Fa-f]{3,4}$/) === 0) {
      val = val.split("").map(function(c) {
        return c + c;
      }).join("").substr(1);
    }

    if (val.match(/^#[0-9A-Fa-f]{6,8}$/)) {
      var rgb = parseInt(val.substr(1), 16);
      var blue = rgb & 0xFF;
      rgb >>= 8;
      var green = rgb & 0xFF;
      rgb >>= 8;
      var red = rgb & 0xFF;
      rgb >>= 8;
      var alpha = (val.length === 9) ? (rgb & 0xFF) : 255;

      var uicolor = options.appkit ? "NSColor" : "UIColor";
      row += uicolor + "(red: " + c(red) + ", green: " + c(green) + ", blue:" + c(blue) + ", alpha: " + c(alpha) + ")";
    } else {
      row += JSON.stringify(val);
    }

    return row;
  }

  function c(val) {
    return Math.round(val / 255 * 1000) / 1000;
  }

  function dimenFilter(key, val) {
    if (!val) return;
    return prefix(key) + ": CGFloat = " + parseFloat(val);
  }

  function boolFilter(key, val) {
    return prefix(key) + " = " + val;
  }
}

function makeExtension(type, src, filter, options) {
  var rows = [];

  if (src) Object.keys(src).forEach(function(key) {
    var val = src[key];
    var row = filter(key, val);
    if (!row) return;

    var comment = ("object" === typeof val) && val.comment;
    if (comment instanceof Array) {
      comment.forEach(function(str) {
        if (str) rows.push(makeComment(str));
      });
    } else {
      if (comment) rows.push(makeComment(comment));
    }

    rows.push(makeComment(val));

    rows.push(row);
  });

  if (rows.length) {
    var className = options[CLASS] || "R";
    className += "." + type;
    rows.unshift("extension " + className + " {");
    rows.push("}");
    rows.push("");
  }

  return rows;
}

function makeComment(val) {
  if (val === "") val = "(empty)";
  val += "";
  val = val.replace(/\r/g, "\\r");
  val = val.replace(/\n/g, "\\n");
  val = val.replace(/\t/g, "\\t");
  val = val.replace(/\s+/g, " ");
  if (val.length > MAX_COMMENT_LENGTH) {
    val = val.substr(0, MAX_COMMENT_LENGTH) + "...";
  }
  return "    /// " + val;
}

function prefix(key) {
  key = key.replace(Identifier.isOperatorStartCodePoint, "_");
  key = key.replace(Identifier.isOperatorContinuationCodePoint, "_");

  if (TokenKinds[key]) {
    key = "`" + key + "`";
  }
  return "    static let " + key;
}
